from specutils import Spectrum1D
from features import Features
import copy


class Model:
    """This class acts as the main API for PAHFIT.

    The users deal with model objects, of which the state is modified
    during initalization, initial guessing, and fitting. What the model
    STORES is a description of the physics: what features are there and
    what are their properties, regardless of the instrument with which
    those features are observed. The methods provided by this class,
    form the connection between those physics, and what is observed.
    During fitting and plotting, those physics are converted into a
    model for the observation, by applying instrumental parameters from
    the instrument.py module.

    The main thing that defines a model, is the features table, loaded
    from a YAML file given to the constructor. After construction, the
    Model can be edited by accessing the stored features table directly.
    Changing numbers in this table, is allowed, and the updated numbers
    will be reflected when the next fit or initial guess happens. At the
    end of these actions, the fit or guess results are stored in the
    same table.

    The model can be saved.

    The model can be copied.

    Attributes
    ----------
    features : Features
        Instance of the Features class. Can be edited on-the-fly.
        Non-breaking behavior by the user is expected. Changes will be
        reflected at the next fit, guess, or plot call.

    """

    def __init__(self, features: Features, instrumentname, redshift):
        """
        Parameters
        ----------
        features: Features
            Features table.

        instrumentname : str or list of str
            Qualified instrument name, see instrument.py. This will
            determine what the line widths are, when going from the features
            table to a fittable/plottable model.

        redshift : float
            Redshift used to shift from the physical model, to the observed model.
        """
        self.redshift = redshift
        self.instrumentname = instrumentname
        self.features = features

    @classmethod
    def from_yaml(cls, pack_file, instrumentname, redshift):
        """
        Parameters
        ----------
        pack_file : str
            Path to YAML file, or path to stored results table. The feature
            table is generated based on this input.

        Returns
        -------
        Model instance

        """
        features = Features.read(pack_file)
        return cls(features, instrumentname, redshift)

    @classmethod
    def from_saved(cls, saved_model_file):
        """
        Parameters
        ----------
        saved_model_file : str
           File generated by Model.save()

        Returns
        -------
        Model instance
        """
        # features.read automatically switches to astropy table reader.
        # Maybe needs to be more advanced here in the future. TODO: make
        # sure we get the metadata too! Redshift, uncertinties (fit
        # result parameters are already stored in the main table, so
        # that should be fine)
        features = Features.read(saved_model_file)
        metadata_mock = {"redshift": 0.0, "instrumentname": "bla"}
        return cls(features, metadata_mock["instrumentname"], metadata_mock["redshift"])

    def guess(self, spec: Spectrum1D):
        """Make an initial guess of the physics, based on the given
        observational data.

        Parameters
        ----------
        spec : Spectrum1D
            1D (not 2D or 3D) spectrum object, containing the
            observational data. (TODO: should support list of spectra,
            for the segment-based joint fitting). Initial guess will be
            based on the flux in this spectrum.

        Returns
        -------
        Nothing, but internal feature table is updated.

        """
        pass

    def plot(self, spec=None):
        """Plot model, and optionally compare to observational data.

        Parameters
        ----------
        spec : Spectrum1D
            Observational data. Does not have to be the same data that
            was used for guessing or fitting.
        """
        pass

    def fit(self, spec: Spectrum1D):
        """Create a model, fit it, and store the results in the features table"""
        pass

    def _construct_astropy_model(self):
        """Convert the features table into a fittable model."""
        pass

    def _parse_astropy_result(self):
        """Store the result of the astropy fit into the features table

        Every relevant value inside the astropy model, is written to the
        right position in the features table. This way, the astropy
        model and the features table are kept in sync.

        Doing things this way, makes it possible for the user to make
        edits to the features table, and makes it easy to store the
        model (just store the features table)"""
        pass

    def info(self):
        """Print out the last fit results."""
        pass

    def copy(self):
        """Copy the model.

        Main use case: use this model as a parent model for more
        fits.

        Currently uses copy.deepcopy. We should do something smarter if
        we run into memory problems or sluggishness.

        Returns
        -------
        model_copy : Model
        """
        # We could do this
        # make new instance
        # model_copy = type(self)(self.pack_file, self.instrumentname, self.redshift)
        # copy over all the variables that might have changed
        # make sure to deep copy the table!

        # But maybe try this first
        return copy.deepcopy(self)

    def save(self, fn):
        """Save the model to disk.

        This will save the features table using its builtin write
        function from astropy.table.

        Format TDB. Currently depends on file extension given, same as
        astropy.

        Models saved this way can be read in.

        Parameters
        ----------
        fn : file name

        """
        self.features.write(fn)
