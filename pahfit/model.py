from specutils import Spectrum1D
from astropy import units as u
import copy
from astropy.modeling.fitting import LevMarLSQFitter
from matplotlib import pyplot as plt
import numpy as np

from pahfit.features import Features
from pahfit.base import PAHFITBase
from pahfit import instrument
from pahfit.errors import PAHFITModelError


class Model:
    """This class acts as the main API for PAHFIT.

    The users deal with model objects, of which the state is modified
    during initalization, initial guessing, and fitting. What the model
    STORES is a description of the physics: what features are there and
    what are their properties, regardless of the instrument with which
    those features are observed. The methods provided by this class,
    form the connection between those physics, and what is observed.
    During fitting and plotting, those physics are converted into a
    model for the observation, by applying instrumental parameters from
    the instrument.py module.

    The main thing that defines a model, is the features table, loaded
    from a YAML file given to the constructor. After construction, the
    Model can be edited by accessing the stored features table directly.
    Changing numbers in this table, is allowed, and the updated numbers
    will be reflected when the next fit or initial guess happens. At the
    end of these actions, the fit or guess results are stored in the
    same table.

    The model can be saved.

    The model can be copied.

    Attributes
    ----------
    features : Features
        Instance of the Features class. Can be edited on-the-fly.
        Non-breaking behavior by the user is expected. Changes will be
        reflected at the next fit, guess, or plot call.

    """

    def __init__(self, features: Features):
        """
        Parameters
        ----------
        features: Features
            Features table.

        """
        if len(features) < 2:
            raise PAHFITModelError(
                "Fewer than 2 features! Single component models are no allowed!"
            )

        self.features = features

        # If features table does not originate from a previous fit, and
        # hence has no unit yet, we initialize it as None.
        if "unit" not in self.features.meta:
            self.features.meta["unit"] = None

        # if set to False, use set fwhm for lines to value in features
        # table at model construction
        self.use_instrument_fwhm = True

        # store fit_info dict of last fit
        self.fit_info = None

    @classmethod
    def from_yaml(cls, pack_file):
        """
        Generate feature table from YAML file.

        Parameters
        ----------
        pack_file : str
            Path to YAML file, or name of one of the default YAML files.

        Returns
        -------
        Model instance

        """
        features = Features.read(pack_file)
        return cls(features)

    @classmethod
    def from_saved(cls, saved_model_file):
        """
        Parameters
        ----------
        saved_model_file : str
           Path to file generated by Model.save()

        Returns
        -------
        Model instance
        """
        # features.read automatically switches to astropy table reader.
        # Maybe needs to be more advanced here in the future.
        features = Features.read(saved_model_file, format="ascii.ecsv")
        return cls(features)

    def save(self, fn, **write_kwargs):
        """Save the model to disk.

        Only ECSV supported for now. Models saved this way can be read
        back in, with metadata.

        TODO: store details about the fit results somehow. Uncertainties
        (covariance matrix) should be retrievable. Use Table metadata?

        Parameters
        ----------
        fn : file name

        **write_kwargs : kwargs passed to astropy.table.Table.write

        """
        if fn.split(".")[-1] != "ecsv":
            raise NotImplementedError("Only ascii.ecsv is supported for now")

        self.features.meta['use_instrument_fwhm'] = self.use_instrument_fwhm
        self.features.meta['fit_info'] = self.fit_info

        self.features.write(fn, format="ascii.ecsv", **write_kwargs)

    def _status_message(self):
        out = "Model features ("
        if self.fit_info is None:
            out += "not "
        out += "fitted)\n"
        return out

    def __repr__(self):
        return self._status_message() + self.features.__repr__()

    def _repr_html_(self):
        return self._status_message() + self.features._repr_html_()

    def guess(self, spec: Spectrum1D, redshift=None):
        """Make an initial guess of the physics, based on the given
        observational data.

        Parameters
        ----------
        spec : Spectrum1D
            1D (not 2D or 3D) spectrum object, containing the
            observational data. (TODO: should support list of spectra,
            for the segment-based joint fitting). Initial guess will be
            based on the flux in this spectrum.

            spec.meta['instrument'] : str or list of str
                Qualified instrument name, see instrument.py. This will
                determine what the line widths are, when going from the
                features table to a fittable/plottable model.

        redshift : float
            Redshift used to shift from the physical model, to the
            observed model.

            If None, will be taken from spec.redshift

        Returns
        -------
        Nothing, but internal feature table is updated.

        """
        self.features.meta["unit"] = spec.flux.unit
        inst, z = self._parse_instrument_and_redshift(spec, redshift)
        _, _, _, xz, yz, _ = self._convert_spec_data(spec, z)

        # save these as part of the model (will be written to disk too)
        self.features.meta["redshift"] = inst
        self.features.meta["instrument"] = z

        # remake param_info to make sure we have any feature updates from the user
        param_info = self._kludge_param_info(inst, z)
        param_info = PAHFITBase.estimate_init(xz, yz, param_info)
        self._backport_param_info(param_info)

    @staticmethod
    def _convert_spec_data(spec, z):
        """
        Turn astropy quantities into fittable numbers.

        Also corrects for redshift

        Returns
        -------
        x, y, unc: wavelength in micron, flux, uncertainty

        xz, yz, uncz: wavelength in micron, flux, uncertainty
            corrected for redshift
        """
        x = spec.spectral_axis.to(u.micron).value
        y = spec.flux.value
        unc = spec.uncertainty.array

        # transform observed wavelength to "physical" wavelength
        xz = x / (1 + z)  # wavelength shorter
        yz = y * (1 + z)  # energy higher
        uncz = unc * (1 + z)  # uncertainty scales with flux
        return x, y, unc, xz, yz, uncz

    def fit(
        self,
        spec: Spectrum1D,
        redshift=None,
        maxiter=1000,
        verbose=True,
    ):
        """Fit the observed data.

        The model setup is based on the features table and instrument specification.

        The last fit results can accessed through the variable
        model.astropy_result. The results are also stored back to the
        model.features table.

        CAVEAT: any features that do not overlap with the data range
        will not be included in the model, for performance and numerical
        stability. Their values in the features table will be left
        untouched.

        Parameters
        ----------
        spec : Spectrum1D
            1D (not 2D or 3D) spectrum object, containing the
            observational data. (TODO: should support list of spectra,
            for the segment-based joint fitting). Initial guess will be
            based on the flux in this spectrum.

            spec.meta['instrument'] : str or list of str
                Qualified instrument name, see instrument.py. This will
                determine what the line widths are, when going from the
                features table to a fittable/plottable model.

        redshift : float
            Redshift used to shift from the physical model, to the
            observed model.

            If None, will be taken from spec.redshift

        maxiter : int
            maximum number of fitting iterations

        verbose : boolean
            set to provide screen output

        """
        # parse spectral data
        self.features.meta["unit"] = spec.flux.unit
        inst, z = self._parse_instrument_and_redshift(spec, redshift)
        x, _, _, xz, yz, uncz = self._convert_spec_data(spec, z)

        # save these as part of the model (will be written to disk too)
        self.features.meta["redshift"] = inst
        self.features.meta["instrument"] = z

        # check if observed spectrum is compatible with instrument model
        instrument.check_range([min(x), max(x)], inst)

        # weigths
        w = 1.0 / uncz

        # construct model and perform fit
        astropy_model = self._construct_astropy_model(inst, z, use_instrument_fwhm=True)
        fit = LevMarLSQFitter(calc_uncertainties=True)
        self.astropy_result = fit(
            astropy_model,
            xz,
            yz,
            weights=w,
            maxiter=maxiter,
            epsilon=1e-10,
            acc=1e-10,
        )
        self.fit_info = fit.fit_info
        if verbose:
            print(fit.fit_info["message"])

        self._parse_astropy_result(self.astropy_result)

    def info(self):
        """Print out the last fit results."""
        print(self.astropy_result)

    def plot(self, spec=None, redshift=None):
        """Plot model, and optionally compare to observational data.

        Parameters
        ----------
        spec : Spectrum1D
            Observational data. Does not have to be the same data that
            was used for guessing or fitting.

        redshift : float
            Redshift used to shift from the physical model, to the
            observed model.

            If None, will be taken from spec.redshift

        """
        inst, z = self._parse_instrument_and_redshift(spec, redshift)
        _, _, _, xz, yz, uncz = self._convert_spec_data(spec, z)
        astropy_model = self._construct_astropy_model(
            inst, z, use_instrument_fwhm=False
        )

        enough_samples = max(1000, len(spec.wavelength))

        fig, axs = plt.subplots(
            ncols=1,
            nrows=2,
            figsize=(15, 10),
            gridspec_kw={"height_ratios": [3, 1]},
            sharex=True,
        )
        PAHFITBase.plot(axs, xz, yz, uncz, astropy_model, model_samples=enough_samples)
        fig.subplots_adjust(hspace=0)

    def copy(self):
        """Copy the model.

        Main use case: use this model as a parent model for more
        fits.

        Currently uses copy.deepcopy. We should do something smarter if
        we run into memory problems or sluggishness.

        Returns
        -------
        model_copy : Model
        """
        # A standard deepcopy works fine!
        return copy.deepcopy(self)

    def tabulate(
        self,
        instrumentname,
        redshift=0,
        wavelengths=None,
        flux_unit=None,
        feature_mask=None,
    ):
        """Tabulate model flux on a wavelength grid, and export as Spectrum1D

        Parameters
        ----------
        wavelengths : Spectrum1D or array-like
            Wavelengths in micron in the observed frame. Will be
            multiplied with 1/(1+z) if redshift z is given, so that the
            model is evaluated in the rest frame as intended. If a
            Spectrum1D is given, wavelengths.spectral_axis will be
            converted to micron and then used as wavelengths.

        instrumentname : str or list of str
            Qualified instrument name, see instrument.py. This
            determines the wavelength range of features to be included.
            The FWHM of the unresolved lines will be determined by the
            value in the features table, instead of the instrument. This
            allows us to visualize the fitted line widths in the
            spectral overlap regions.

        redshift : float
            The redshift is needed to evaluate the flux model at the
            right rest wavelengths.

        flux_unit : Unit
            Specify or override the flux unit. Needs to be compatible
            with MJy or MJy / sr.

        feature_mask : row mask
            Mask used to select specific rows of the feature table. In
            most use cases, this mask can be made by applying a boolean
            operation to a column of self.features, e.g.
            model.features['wavelength']>8.5

        Returns
        -------
        model_spectrum : Spectrum1D
            The flux model, evaluated at the given wavelengths, packaged
            as a Spectrum1D object.
        """
        # apply feature mask, make sub model, and set up functional
        if feature_mask is not None:
            features_copy = self.features.copy()
            features_to_use = features_copy[feature_mask]
        else:
            features_to_use = self.features
        alt_model = Model(features_to_use)
        flux_function = alt_model._construct_astropy_model(
            instrumentname, redshift, use_instrument_fwhm=False
        )

        # decide which wavelength grid to use
        if wavelengths is None:
            ranges = instrument.wave_range(instrumentname)
            wmin = min(r[0] for r in ranges)
            wmax = max(r[1] for r in ranges)
            wfwhm = instrument.fwhm(instrumentname, wmin, as_bounded=True)[0, 0]
            wav = np.arange(wmin, wmax, wfwhm / 2)
        elif isinstance(wavelengths, Spectrum1D):
            wav = wavelengths.spectral_axis.to(u.micron).value
        else:
            # any other iterable will be accepted and converted to array
            wav = np.asarray(wavelengths)

        # shift the "observed wavelength grid" to "physical wavelength grid"
        wav /= 1 + redshift
        flux_values = flux_function(wav)

        # apply unit stored in features table (comes from from last fit
        # or from loading previous result from disk)
        if self.features.meta["unit"] is None:
            flux_quantity = flux_values * u.dimensionless_unscaled
        else:
            flux_quantity = flux_values * self.features.meta["unit"]

        # apply unit override if requested
        if flux_unit is not None:
            # if dimensionless, set unit
            if flux_quantity.unit == u.dimensionless_unscaled:
                flux_quantity *= flux_unit
            # if already has unit, convert quantity
            else:
                flux_quantity = flux_quantity.to(flux_unit)

        return Spectrum1D(spectral_axis=wav * u.micron, flux=flux_quantity)

    def _kludge_param_info(self, instrumentname, redshift, use_instrument_fwhm=True):
        param_info = PAHFITBase.parse_table(self.features)
        # edit line widths and drop lines out of range

        # h2_info
        param_info[2] = PAHFITBase.update_dictionary(
            param_info[2],
            instrumentname,
            update_fwhms=use_instrument_fwhm,
            redshift=redshift,
        )
        # ion_info
        param_info[3] = PAHFITBase.update_dictionary(
            param_info[3],
            instrumentname,
            update_fwhms=use_instrument_fwhm,
            redshift=redshift,
        )
        # abs_info
        param_info[4] = PAHFITBase.update_dictionary(
            param_info[4], instrumentname, redshift
        )

        return param_info

    def _backport_param_info(self, param_info):
        """Convert param_info to values in features table.

        Temporary hack to make the new system compatible with the old system.

        TODO: if we remove the param_info stuff entirely, we won't need this

        """
        # unfortunately, there is no implementation for this, even in
        # the original code. That one goes straight from astropy model
        # to table... But we can do a kludge here: convert to model
        # first, and then back to table.
        astropy_model = PAHFITBase.model_from_param_info(param_info)
        self._parse_astropy_result(astropy_model)

    def _construct_astropy_model(
        self, instrumentname, redshift, use_instrument_fwhm=True
    ):
        """Convert the features table into a fittable model.

        Some nuances in the behavior
        - If a line has a fwhm set, it will be ignored, and replaced by
          the calculated fwhm provided by the instrument model.
        - If a line has been masked by _parse_astropy_result, and this
          function is called again, those masks will be ignored, as the
          data range might have changed.

        TODO: Make sure the features outside of the data range are
        removed. The instrument-based feature check is done in
        _kludge_param_info(), but the observational data might only
        cover a part of the instrument range.

        """
        param_info = self._kludge_param_info(
            instrumentname, redshift, use_instrument_fwhm
        )
        return PAHFITBase.model_from_param_info(param_info)

    def _parse_astropy_result(self, astropy_model):
        """Store the result of the astropy fit into the features table.

        Every relevant value inside the astropy model, is written to the
        right position in the features table.

        For the unresolved lines, the widths are calculated by the
        instrument model, or fitted when these lines are in a spectral
        overlap region. The calculated or fitted result is written to
        the fwhm field of the table. When a new model is constructed
        from the features table, this fwhm value will be ignored.

        For features that do not correspond to the data range, all
        parameter values will be masked. Their numerical values remain
        accessible by '.data' on the masked entity. This way, We still
        keep their parameter values around (as opposed to removing the
        rows entirely). When data with a larger range are passed for
        another fitting call, those features can be unmasked if
        necessary.

        """
        # Some translation rules between astropy model components and
        # feature table names and values.

        # these have the same value but different (fixed) names
        param_name_equivalent = {
            "temperature": "temperature",
            "fwhm": "fwhm",
            "x_0": "wavelength",
            "mean": "wavelength",
            "tau_sil": "tau",
        }

        def param_conversion(features_kind, param_name, param_value):
            # default conversion
            if param_name in param_name_equivalent:
                new_name = param_name_equivalent[param_name]
                new_value = param_value
            # certain types of features use tau instead of amplitude
            elif param_name == "amplitude":
                if features_kind in ["starlight", "dust_continuum", "absorption"]:
                    new_name = "tau"
                else:
                    new_name = "power"
                new_value = param_value
            # convert stddev to fwhm
            elif param_name == "stddev":
                new_name = "fwhm"
                new_value = param_value * 2.355
            else:
                raise NotImplementedError(
                    f"no conversion rule for model parameter {param_name}"
                )
            return new_name, new_value

        # Go over all features.
        for row in self.features:
            name = row["name"]
            if name in astropy_model.submodel_names:
                # undo any previous masking that might have occured
                self.features.unmask_feature(name)

                # copy or translate, and store the parameters
                component = astropy_model[name]
                for param_name in component.param_names:
                    param_value = getattr(component, param_name).value
                    col_name, col_value = param_conversion(
                        row["kind"], param_name, param_value
                    )
                    row[col_name][0] = col_value

                # for the unresolved lines, indicate when the line fwhm was made non-fixed
                if row["kind"] == "line" and col_name == "fwhm":
                    row["fwhm"].mask[1:] = component.fixed[param_name]
            else:
                # signal that it was not fit by masking the feature
                self.features.mask_feature(name)

    @staticmethod
    def _parse_instrument_and_redshift(spec, redshift):
        """Small utility to grab instrument and redshift from either
        Spectrum1D metadata, or from arguments.

        """
        # the rest of the implementation doesn't like Quantity...
        z = spec.redshift.value if redshift is None else redshift
        if z is None:
            # default of spec.redshift is None!
            z = 0

        inst = spec.meta["instrument"]
        if inst is None:
            raise PAHFITModelError("No instrument! Please set spec.meta['instrument'].")

        return inst, z
